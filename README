This python project is to demonstrate the working of
 -Simplified IDEA and
 -ElGamal Encryption Algorithm
 
Requiements:
python 3.8.0

How to run:
-To run the script open your terminal.
-go to the folder where all files are placed.
-execute server script `py server.py`.
-then open one another teminal and go tho same folder.
-execute client script `py client.py`.
-enter a 16-bit msg
-enter a 16 bit key(it will automatically make it 32-bit).

Description of IDEA and ElGamal


file descriptions
server.py:
    This is the server side script. A server socket will be created and binded to the local host.
    server will create its public and private keys. when a client connects to the server and ask for public key server will provide that to client.
    then client sends the encrypted secret key to the server.
    server recieves the encrypted secret key and decrypts it using elgamal algorithn to get the original secrete key.
    then client send the cipher text (encryted message) to the server.
    server recieves the cipher text and decrypts it using simplified IDEA with the secret key to get the original message.

client.py:
    This is the client side script. A client socket will be created and connect to the local server.
    firstly a request will be sent to the server for it's public key.
    then the Message and the secret key will be taken from the user through input.
    then the secret key will be encrypted using the ElGamal algorithm and sent to the server.
    the message will be encrypted using the simplified IDEA and sent to the server.

encryption.py:
    This contains all the necessary function for encryption process of simplified IDEA.
    keygenerator(secret key)- a secret key will be provided to this function and it will generate 32 keys by shifting the 6-bits to the left.
        -return a keys as a list containing 32 elements.
        -only first 28 keys will be used for encryption.
    round(round no, PT_nibbles , keys)- this takes round number , plaintext/intermediate ciphertext and round keys as argument.
        -it returns the cipher text in the binary nibbles(4-nibbles).
        -it performs 14 steps which are the combination of three operations: XOR, addition modulo 16 and multiplication modulo 17.
    finalrounds(round no, PT_nibbles , keys)-this also takes intermediate cipher text and key.
        -it returns the final cipher text(intermediate) in the binary nibbles(4-nibbles).
    bToS(bit nibbles)-this takes the binary nibbles form of cipher text and convet it into a string.
        -then the string form of cipher text is used for further processing.
    encryption(Message , secret key)-takes message and key as argument and return ciphertext for the message as a string.

decryption.py:
    This contains all the necessary function for decryption process of simplified IDEA.
    keygenerator(secret key)- a secret key will be provided to this function and it will generate 32 keys by shifting the 6-bits to the left.
        -return a keys as a list containing 32 elements.
        -only first 28 keys will be used for decryption.
    arrange(subkeys)-this will take subkeys generated by keygenerator.
        -then it will arrange it in the order they requiered for dercryption step.
    getinvers(subkeys)- this will find the inverse for every subkey w.r.t the operation performed.
    round(round no, PT_nibbles , keys)- this takes round number , plaintext/intermediate ciphertext and round keys as argument.
        -it returns the cipher text(intermediate) in the binary nibbles(4-nibbles).
        -it performs 14 steps which are the combination of three operations: XOR, addition modulo 16 and multiplication modulo 17.
        -these step are the inverses of encryption process.
    finalrounds(round no, PT_nibbles , keys)-this also takes intermediate cipher text and key.
        -it returns the final cipher text in the binary nibbles(4-nibbles).
    bToS(bit nibbles)-this takes the binary nibbles form of cipher text and convet it into a string.
        -then the string form of cipher text is used for further processing.
    decryption(Message , secret key)-takes message and key as argument and return ciphertext for the message as a string.
elgamal.py:
    gcd()- finds the gcd using euclidian algorithm.
    gen_key(q)- takes a large prime and finds d(primitive root in <G*p,*>).
    power(a,b,m)- finds the power a^b in modulo m.
    encrypt(msg, prime , e1, e2)- takes public key and the msg to encrypt and retrun the encrypted msg.
    decrypt(encrypted_msg, c1,d , prime)- takes cipher text c1, c2 and private key and decrypts the msg.
    generate_keys()- return the public and private key for elgamal encryption/decryption.